
import argparse
import sys
import csv
from scilifelab.utils.fastq_utils import BarcodeExtractor
from scilifelab.utils.string import hamming_distance
from scilifelab.illumina.hiseq import HiSeqRun
from scilifelab.illumina import map_index_name
from collections import Counter
      
def extract_barcodes(fqfile, lane, nindex=25, casava18=True, offset=101, bclen=6, expected=[], mismatch=True):
    """Parse the fastq file and extract barcodes. Return a dict structure suitable for upload to StatusDB
    """
    
    bcx = BarcodeExtractor(fqfile, casava18, offset, bclen)
    c = Counter(bcx)
    c = remove_expected(c,expected,mismatch)
    counts = []
    header = ['lane', 'sequence', 'count', 'index_name']
    for bc, count in c.most_common(nindex):
        counts.append(dict(zip(header,
                               [lane, bc, count, ','.join(map_index_name(bc,int(mismatch)))])))
        
    return [header, counts]

def write_metrics(header, counts):
    """Write the counts to stdout
    """
    # Write the metrics data
    if len(counts) > 0:
        csvw = csv.DictWriter(sys.stdout, fieldnames=header, dialect=csv.excel_tab)
        csvw.writeheader()
        csvw.writerows(counts)
          
def generate_mismatches(src):
    """
    Generate a list of all possible nucleotide sequences with one 
    mismatch from the supplied sequence.
    """
    seqs = []
    # Mutate each position
    src_list = list(src)
    for i in xrange(len(src_list)):
        # Change to all possible nucleotides
        for n in "ACGTN":
            src_list[i] = n
            seqs.append("".join(src_list))
        # Reset the mutated nucleotide
        src_list[i] = src[i]
        
    return list(set(seqs))

def remove_expected(bc_counter, expected_bc, mismatch=False):
    """
    Remove the entries corresponding to the supplied list of expected barcodes, 
    optionally allowing for one mismatch 
    """
    for bc in expected_bc:
        if mismatch:
            bcs = generate_mismatches(bc)
        else:
            bcs = [bc]
            
        for b in bcs:
            del bc_counter[b]
            
    return bc_counter
    
def get_expected(csv_file, lane):
    """Extract the expected barcodes in a lane from a supplied csv samplesheet
    """
    rows = HiSeqRun.parse_samplesheet(csv_file,lane=lane)
    return [r["Index"] for r in rows]
   
def main():
    
    parser = argparse.ArgumentParser(description="""Extract and count barcodes indices from fastq file""")

    parser.add_argument('-o','--offset', action='store', default=101, 
                        help="The offset into the read where the barcode sequence starts. Only used for Casava 1.7- files.")
    parser.add_argument('-b','--barcode-length', dest='barcode_length', action='store', default=6, 
                        help="The length of the barcode sequence. Only used for Casava 1.7- files.")
    parser.add_argument('-n','--nindex', dest='nindex', action='store', default=25, 
                        help="The number of top indexes to report.")
    parser.add_argument('--1.7', dest='casava18', action='store_false', default=True, 
                        help="The sequence file was generated by Casava 1.7-.")
    parser.add_argument('--no-mismatch', dest='mismatch', action='store_false', default=True, 
                        help="Require exact sequence match for barcode lookups. Default is to allow one mismatch")
    parser.add_argument('--csv-file', dest='csvfile', action='store', default=None, 
                        help="The csv samplesheet for the run. If supplied, will be used together with lane " \
                        "to exclude expected barcodes")
    parser.add_argument('infile', action='store',
                        help="The input FastQ file to process. Can be gzip compressed")
    parser.add_argument('lane', action='store', default=None, 
                        help="The lane to be analyzed")
    
    args = parser.parse_args()
    expected = []
    if args.csvfile is not None:
        expected = get_expected(args.csvfile,args.lane)
    
    header, counts = extract_barcodes(args.infile, args.lane, int(args.nindex), args.casava18, int(args.offset), int(args.barcode_length), expected, args.mismatch)
    write_metrics(header, counts)
    
if __name__ == "__main__":
    main()
 