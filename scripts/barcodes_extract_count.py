
import argparse
import sys
import csv
from scilifelab.utils.fastq_utils import BarcodeExtractor
from scilifelab.utils.string import hamming_distance
from scilifelab.illumina.hiseq import HiSeqRun
from scilifelab.illumina import map_index_name
from collections import Counter

def extract_barcodes(fqfile, nindex, casava18, offset, bclen, mismatch, expected=[]):
    """Parse the fastq file and extract barcodes. Return a dict structure suitable for upload to StatusDB
    """
    
    bcx = BarcodeExtractor(fqfile, casava18, offset, bclen)
    c = Counter(bcx)
    c = remove_expected(c,expected,mismatch)
    counts = []
    
    for bc, count in c.most_common(nindex):
        counts.append({'Index': bc,
                       'Reads': count,
                       'Names': ','.join(map_index_name(bc,int(mismatch)))})
        
    return counts

def write_metrics(counts, outfile=None):
    """Write the counts to a csv metrics file
    """
    
    if outfile is not None:
        outh = open(outfile,"w")
    else:
        outh = sys.stdout
        
    # Write the metrics data
    if len(counts) > 0:
        csvw = csv.DictWriter(sys.stdout, counts[0].keys(), dialect=csv.excel_tab)
        csvw.writeheader()
        csvw.writerows(counts)
        
    if outfile is not None:
        outh.close()
        
    return outfile
       
def generate_mismatches(src):
    """
    Generate a list of all possible nucleotide sequences with one 
    mismatch from the supplied sequence.
    """
    seqs = []
    # Mutate each position
    src_list = list(src)
    for i in xrange(len(src_list)):
        # Change to all possible nucleotides
        for n in "ACGT":
            src_list[i] = n
            seqs.append("".join(src_list))
    
    return list(set(seqs))

def remove_expected(bc_counter, expected_bc, mismatch=False):
    """
    Remove the entries corresponding to the supplied list of expected barcodes, 
    optionally allowing for one mismatch 
    """
    for bc in expected_bc:
        if mismatch:
            bcs = generate_mismatches(bc)
        else:
            bcs = [bc]
            
        for b in bcs:
            del bc_counter[b]
            
    return bc_counter
    
def get_expected(csv_file, lane):
    """Extract the expected barcodes in a lane from a supplied csv samplesheet
    """
    rows = HiSeqRun.parse_samplesheet(csv_file,lane=lane)
    return [r["Index"] for r in rows]
   
def main():
    
    parser = argparse.ArgumentParser(description="""Extract and count barcodes indices from fastq file""")

    parser.add_argument('-o','--offset', action='store', default=101, 
                        help="The offset into the read where the barcode sequence starts. Only used for Casava 1.7- files.")
    parser.add_argument('-b','--barcode-length', dest='barcode_length', action='store', default=6, 
                        help="The length of the barcode sequence. Only used for Casava 1.7- files.")
    parser.add_argument('-n','--nindex', dest='nindex', action='store', default=25, 
                        help="The number of top indexes to report.")
    parser.add_argument('--1.7', dest='casava18', action='store_false', default=True, 
                        help="The sequence file was generated by Casava 1.7-.")
    parser.add_argument('--no-mismatch', dest='mismatch', action='store_false', default=True, 
                        help="Require exact sequence match for barcode lookups. Default is to allow one mismatch")
    parser.add_argument('--csv-file', dest='csvfile', action='store', default=None, 
                        help="The csv samplesheet for the run. If supplied, will be used together with --lane to exclude expected barcodes")
    parser.add_argument('--lane', dest='lane', action='store', default=None, 
                        help="The lane to be analyzed. Used together with --csv-file to exclude expected barcodes")
    parser.add_argument('-m','--metrics-file', dest='outfile', action='store', default=None,
                        help="The output metrics file to write to. Default is stdout")
    parser.add_argument('infile', action='store',
                        help="The input FastQ file to process. Can be gzip compressed")
    
    
    args = parser.parse_args()
    assert args.csvfile is None or args.lane is not None, "--lane must be specified if --csv-file is supplied"
    expected = []
    if args.csvfile is not None:
        expected = get_expected(args.csvfile,args.lane)
    
    counts = extract_barcodes(args.infile, args.nindex, args.casava18, args.offset, args.barcode_length, args.mismatch, expected)
    write_metrics(counts,args.outfile)
    
if __name__ == "__main__":
    main()
 